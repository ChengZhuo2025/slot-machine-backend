# 杜美人管理系统技术架构设计方案

## 一、项目概述

### 1.1 项目背景
杜美人管理系统是一个基于物联网技术的综合性管理平台，旨在为用户提供便捷的开锁服务，为商户提供高效的设备管理和运营工具。系统采用现代化的微服务架构，支持多终端访问，建立完整的商业运营生态系统。

### 1.2 技术目标
- **高可用性**：系统可用性达到99.9%以上
- **高并发**：支持万级并发用户访问
- **响应性能**：API响应时间 < 200ms，页面加载时间 < 2s
- **扩展性**：支持水平扩展，模块化部署
- **安全性**：多层次安全防护，数据加密传输
- **易维护性**：代码规范化，文档完善，便于维护升级

### 1.3 核心特性
- 统一响应式管理后台，支持PC/平板/手机多端适配
- 多角色权限控制系统（RBAC）
- 实时设备监控和远程控制
- 完整的支付体系和营销工具
- 多商户、多场地分级管理
- 数据分析和财务管理

## 二、技术架构总览

### 2.1 整体架构图

```mermaid
graph TB
    subgraph "客户端层"
        A[统一管理后台<br/>Vue Vben Admin]
        B[商户小程序<br/>Uni-app]
        C[用户H5端<br/>Vue 3 + Vant]
    end
    
    subgraph "网关层"
        D[API网关<br/>Nginx + Kong]
        E[负载均衡<br/>Nginx]
    end
    
    subgraph "应用服务层"
        F[用户服务]
        G[设备服务]
        H[订单服务]
        I[商户服务]
        J[支付服务]
        K[物联网服务]
    end
    
    subgraph "数据层"
        L[MySQL 8.0<br/>主数据库]
        M[Redis 6.0<br/>缓存/会话]
        N[阿里云OSS<br/>文件存储]
    end
    
    subgraph "物联网层"
        O[MQTT Broker<br/>EMQ X]
        P[智能设备]
    end
    
    A --> D
    B --> D
    C --> D
    D --> E
    E --> F
    E --> G
    E --> H
    E --> I
    E --> J
    E --> K
    F --> L
    G --> L
    H --> L
    I --> L
    J --> L
    K --> L
    F --> M
    G --> M
    H --> M
    K --> O
    O --> P
    F --> N
    G --> N
```

### 2.2 技术栈选型

#### 2.2.1 前端技术栈
| 应用 | 技术栈 | 说明 |
|------|--------|------|
| 统一管理后台 | Vue Vben Admin (Vue 3 + Element Plus + TypeScript) | 响应式设计，多角色权限控制 |
| 商户小程序 | Uni-app + Vue 3 + TypeScript | 跨平台开发，支持微信小程序 |
| 用户H5端 | Vue 3 + Vant UI + TypeScript | 移动端优化，响应式设计 |

#### 2.2.2 后端技术栈
| 组件 | 技术选型 | 版本 | 说明 |
|------|----------|------|------|
| 后端框架 | Node.js + Nest.js | Node.js ≥18.0, Nest.js 10.x | 企业级框架，TypeScript支持 |
| 数据库 | MySQL | 8.0 | 主数据存储 |
| 缓存 | Redis | 6.0 | 缓存和会话管理 |
| 消息队列 | MQTT Broker (EMQ X) | 5.x | 物联网设备通信 |
| 文件存储 | 阿里云OSS | - | 图片、视频等文件存储 |
| API网关 | Kong | 3.x | API管理和限流 |
| 负载均衡 | Nginx | 1.20+ | 反向代理和负载均衡 |

#### 2.2.3 开发工具链
| 工具类型 | 选型 | 说明 |
|----------|------|------|
| 包管理器 | pnpm | 高效的包管理工具 |
| 构建工具 | Vite | 快速的前端构建工具 |
| 代码规范 | ESLint + Prettier | 代码质量保证 |
| 测试框架 | Vitest + Jest | 单元测试和集成测试 |
| 容器化 | Docker + Docker Compose | 容器化部署 |
| CI/CD | GitLab CI/CD | 持续集成和部署 |

## 三、系统架构设计

### 3.1 微服务架构设计

#### 3.1.1 服务拆分原则
- **业务边界清晰**：按业务领域拆分服务
- **数据独立**：每个服务拥有独立的数据库
- **接口标准化**：统一的API设计规范
- **服务自治**：服务可独立开发、部署、扩展

#### 3.1.2 核心服务模块

```typescript
// 服务架构定义
interface ServiceArchitecture {
  // 用户管理服务
  userService: {
    responsibilities: ['用户注册登录', '用户信息管理', '权限验证']
    database: 'user_db'
    port: 3001
  }
  
  // 设备管理服务
  deviceService: {
    responsibilities: ['设备注册', '设备状态监控', '设备配置管理']
    database: 'device_db'
    port: 3002
  }
  
  // 订单服务
  orderService: {
    responsibilities: ['订单创建', '订单状态管理', '订单查询']
    database: 'order_db'
    port: 3003
  }
  
  // 支付服务
  paymentService: {
    responsibilities: ['支付处理', '退款管理', '财务对账']
    database: 'payment_db'
    port: 3004
  }
  
  // 商户服务
  merchantService: {
    responsibilities: ['商户管理', '场地管理', '分成计算']
    database: 'merchant_db'
    port: 3005
  }
  
  // 物联网服务
  iotService: {
    responsibilities: ['设备通信', '指令下发', '状态上报']
    database: 'iot_db'
    port: 3006
  }
}
```

### 3.2 数据库设计

#### 3.2.1 数据库架构
```sql
-- 用户数据库 (user_db)
CREATE DATABASE user_db DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- 用户表
CREATE TABLE users (
  id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid VARCHAR(36) NOT NULL UNIQUE COMMENT '用户UUID',
  username VARCHAR(50) UNIQUE COMMENT '用户名',
  email VARCHAR(100) UNIQUE COMMENT '邮箱',
  phone VARCHAR(20) UNIQUE COMMENT '手机号',
  password_hash VARCHAR(255) NOT NULL COMMENT '密码哈希',
  avatar_url VARCHAR(500) COMMENT '头像URL',
  nickname VARCHAR(50) COMMENT '昵称',
  gender TINYINT DEFAULT 0 COMMENT '性别：0未知，1男，2女',
  birth_date DATE COMMENT '出生日期',
  status TINYINT DEFAULT 1 COMMENT '状态：0禁用，1启用',
  is_verified BOOLEAN DEFAULT FALSE COMMENT '是否验证',
  last_login_at TIMESTAMP NULL COMMENT '最后登录时间',
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  deleted_at TIMESTAMP NULL COMMENT '软删除时间',
  
  INDEX idx_username (username),
  INDEX idx_email (email),
  INDEX idx_phone (phone),
  INDEX idx_status (status),
  INDEX idx_created_at (created_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- 角色表
CREATE TABLE roles (
  id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  name VARCHAR(50) NOT NULL UNIQUE COMMENT '角色名称',
  display_name VARCHAR(100) COMMENT '显示名称',
  description TEXT COMMENT '角色描述',
  permissions JSON COMMENT '权限列表',
  status TINYINT DEFAULT 1 COMMENT '状态：0禁用，1启用',
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- 用户角色关联表
CREATE TABLE user_roles (
  id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  user_id BIGINT UNSIGNED NOT NULL,
  role_id BIGINT UNSIGNED NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  
  UNIQUE KEY uk_user_role (user_id, role_id),
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
  FOREIGN KEY (role_id) REFERENCES roles(id) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- 设备数据库 (device_db)
CREATE DATABASE device_db DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- 设备表
CREATE TABLE devices (
  id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid VARCHAR(36) NOT NULL UNIQUE COMMENT '设备UUID',
  device_code VARCHAR(50) NOT NULL UNIQUE COMMENT '设备编码',
  device_name VARCHAR(100) NOT NULL COMMENT '设备名称',
  device_type VARCHAR(50) NOT NULL COMMENT '设备类型',
  model VARCHAR(50) COMMENT '设备型号',
  firmware_version VARCHAR(20) COMMENT '固件版本',
  hardware_version VARCHAR(20) COMMENT '硬件版本',
  mac_address VARCHAR(17) COMMENT 'MAC地址',
  ip_address VARCHAR(15) COMMENT 'IP地址',
  location JSON COMMENT '位置信息',
  venue_id BIGINT UNSIGNED COMMENT '场地ID',
  merchant_id BIGINT UNSIGNED COMMENT '商户ID',
  status TINYINT DEFAULT 1 COMMENT '设备状态：0离线，1在线，2维护中，3故障',
  health_status TINYINT DEFAULT 1 COMMENT '健康状态：0异常，1正常',
  last_heartbeat TIMESTAMP NULL COMMENT '最后心跳时间',
  install_date DATE COMMENT '安装日期',
  warranty_date DATE COMMENT '保修到期日期',
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  deleted_at TIMESTAMP NULL,
  
  INDEX idx_device_code (device_code),
  INDEX idx_venue_id (venue_id),
  INDEX idx_merchant_id (merchant_id),
  INDEX idx_status (status),
  INDEX idx_last_heartbeat (last_heartbeat)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- 设备配置表
CREATE TABLE device_configs (
  id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  device_id BIGINT UNSIGNED NOT NULL,
  config_key VARCHAR(100) NOT NULL,
  config_value TEXT,
  config_type VARCHAR(20) DEFAULT 'string' COMMENT '配置类型：string,number,boolean,json',
  description VARCHAR(255) COMMENT '配置描述',
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  
  UNIQUE KEY uk_device_config (device_id, config_key),
  FOREIGN KEY (device_id) REFERENCES devices(id) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- 订单数据库 (order_db)
CREATE DATABASE order_db DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- 订单表
CREATE TABLE orders (
  id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid VARCHAR(36) NOT NULL UNIQUE COMMENT '订单UUID',
  order_no VARCHAR(32) NOT NULL UNIQUE COMMENT '订单号',
  user_id BIGINT UNSIGNED NOT NULL COMMENT '用户ID',
  device_id BIGINT UNSIGNED NOT NULL COMMENT '设备ID',
  merchant_id BIGINT UNSIGNED NOT NULL COMMENT '商户ID',
  venue_id BIGINT UNSIGNED NOT NULL COMMENT '场地ID',
  product_info JSON COMMENT '商品信息',
  total_amount DECIMAL(10,2) NOT NULL COMMENT '订单总金额',
  discount_amount DECIMAL(10,2) DEFAULT 0.00 COMMENT '优惠金额',
  actual_amount DECIMAL(10,2) NOT NULL COMMENT '实付金额',
  payment_method VARCHAR(20) COMMENT '支付方式',
  payment_status TINYINT DEFAULT 0 COMMENT '支付状态：0待支付，1已支付，2已退款',
  order_status TINYINT DEFAULT 0 COMMENT '订单状态：0待支付，1已支付，2已完成，3已取消',
  unlock_status TINYINT DEFAULT 0 COMMENT '开锁状态：0未开锁，1已开锁，2开锁失败',
  unlock_time TIMESTAMP NULL COMMENT '开锁时间',
  completed_at TIMESTAMP NULL COMMENT '完成时间',
  expired_at TIMESTAMP NULL COMMENT '过期时间',
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  
  INDEX idx_order_no (order_no),
  INDEX idx_user_id (user_id),
  INDEX idx_device_id (device_id),
  INDEX idx_merchant_id (merchant_id),
  INDEX idx_payment_status (payment_status),
  INDEX idx_order_status (order_status),
  INDEX idx_created_at (created_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- 商户数据库 (merchant_db)
CREATE DATABASE merchant_db DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- 商户表
CREATE TABLE merchants (
  id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid VARCHAR(36) NOT NULL UNIQUE COMMENT '商户UUID',
  merchant_code VARCHAR(50) NOT NULL UNIQUE COMMENT '商户编码',
  merchant_name VARCHAR(100) NOT NULL COMMENT '商户名称',
  contact_person VARCHAR(50) COMMENT '联系人',
  contact_phone VARCHAR(20) COMMENT '联系电话',
  contact_email VARCHAR(100) COMMENT '联系邮箱',
  business_license VARCHAR(100) COMMENT '营业执照号',
  address TEXT COMMENT '地址',
  settlement_config JSON COMMENT '结算配置',
  commission_rate DECIMAL(5,4) DEFAULT 0.1000 COMMENT '分成比例',
  status TINYINT DEFAULT 1 COMMENT '状态：0禁用，1启用',
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  deleted_at TIMESTAMP NULL,
  
  INDEX idx_merchant_code (merchant_code),
  INDEX idx_status (status)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- 场地表
CREATE TABLE venues (
  id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid VARCHAR(36) NOT NULL UNIQUE COMMENT '场地UUID',
  venue_code VARCHAR(50) NOT NULL UNIQUE COMMENT '场地编码',
  venue_name VARCHAR(100) NOT NULL COMMENT '场地名称',
  merchant_id BIGINT UNSIGNED NOT NULL COMMENT '商户ID',
  address TEXT COMMENT '详细地址',
  location JSON COMMENT '地理位置信息',
  venue_type VARCHAR(50) COMMENT '场地类型',
  operating_hours JSON COMMENT '营业时间',
  contact_person VARCHAR(50) COMMENT '现场联系人',
  contact_phone VARCHAR(20) COMMENT '联系电话',
  status TINYINT DEFAULT 1 COMMENT '状态：0禁用，1启用',
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  deleted_at TIMESTAMP NULL,
  
  INDEX idx_venue_code (venue_code),
  INDEX idx_merchant_id (merchant_id),
  INDEX idx_status (status),
  FOREIGN KEY (merchant_id) REFERENCES merchants(id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

#### 3.2.2 索引优化策略
```sql
-- 复合索引设计
-- 用户查询优化
ALTER TABLE users ADD INDEX idx_status_created (status, created_at);
ALTER TABLE users ADD INDEX idx_status_login (status, last_login_at);

-- 设备查询优化
ALTER TABLE devices ADD INDEX idx_venue_status (venue_id, status);
ALTER TABLE devices ADD INDEX idx_merchant_status (merchant_id, status);
ALTER TABLE devices ADD INDEX idx_status_heartbeat (status, last_heartbeat);

-- 订单查询优化
ALTER TABLE orders ADD INDEX idx_user_status_created (user_id, order_status, created_at);
ALTER TABLE orders ADD INDEX idx_device_status_created (device_id, order_status, created_at);
ALTER TABLE orders ADD INDEX idx_merchant_status_created (merchant_id, order_status, created_at);
```

### 3.3 缓存策略设计

#### 3.3.1 Redis缓存架构
```typescript
// 缓存管理服务
@Injectable()
export class CacheService {
  constructor(private redis: Redis) {}
  
  // 用户信息缓存
  async getUserCache(userId: number): Promise<User | null> {
    const cached = await this.redis.get(`user:${userId}`)
    return cached ? JSON.parse(cached) : null
  }
  
  async setUserCache(userId: number, user: User, ttl: number = 3600): Promise<void> {
    await this.redis.setex(`user:${userId}`, ttl, JSON.stringify(user))
  }
  
  // 设备状态缓存
  async getDeviceStatus(deviceId: string): Promise<DeviceStatus | null> {
    const cached = await this.redis.get(`device:status:${deviceId}`)
    return cached ? JSON.parse(cached) : null
  }
  
  async setDeviceStatus(deviceId: string, status: DeviceStatus, ttl: number = 300): Promise<void> {
    await this.redis.setex(`device:status:${deviceId}`, ttl, JSON.stringify(status))
  }
  
  // 会话管理
  async setSession(sessionId: string, data: any, ttl: number = 86400): Promise<void> {
    await this.redis.setex(`session:${sessionId}`, ttl, JSON.stringify(data))
  }
  
  async getSession(sessionId: string): Promise<any | null> {
    const cached = await this.redis.get(`session:${sessionId}`)
    return cached ? JSON.parse(cached) : null
  }
  
  // 分布式锁
  async acquireLock(key: string, ttl: number = 30): Promise<boolean> {
    const result = await this.redis.set(`lock:${key}`, '1', 'EX', ttl, 'NX')
    return result === 'OK'
  }
  
  async releaseLock(key: string): Promise<void> {
    await this.redis.del(`lock:${key}`)
  }
}
```

#### 3.3.2 缓存策略规划
| 数据类型 | 缓存时间 | 更新策略 | 使用场景 |
|----------|----------|----------|----------|
| 用户信息 | 1小时 | 主动更新 | 用户登录状态 |
| 设备状态 | 5分钟 | 实时更新 | 设备监控 |
| 商户信息 | 2小时 | 主动更新 | 商户管理 |
| 系统配置 | 6小时 | 手动刷新 | 全局配置 |
| 用户会话 | 24小时 | 滑动过期 | 登录状态 |
| API限流 | 1分钟 | 自动过期 | 接口保护 |

### 3.4 API网关设计

#### 3.4.1 网关架构
```yaml
# Kong网关配置
services:
  - name: user-service
    url: http://user-service:3001
    routes:
      - name: user-routes
        paths: ["/api/v1/users"]
        methods: ["GET", "POST", "PUT", "DELETE"]
    plugins:
      - name: rate-limiting
        config:
          minute: 100
          hour: 1000
      - name: jwt
        config:
          secret_is_base64: false

  - name: device-service
    url: http://device-service:3002
    routes:
      - name: device-routes
        paths: ["/api/v1/devices"]
        methods: ["GET", "POST", "PUT", "DELETE"]
    plugins:
      - name: rate-limiting
        config:
          minute: 200
          hour: 2000
      - name: jwt
```

#### 3.4.2 API版本管理
```typescript
// API版本控制
export const API_VERSIONS = {
  V1: 'v1',
  V2: 'v2'
} as const

// 版本路由配置
@Controller('api/v1/users')
export class UserV1Controller {
  // V1版本的用户接口
}

@Controller('api/v2/users')
export class UserV2Controller {
  // V2版本的用户接口
}
```

## 四、物联网架构设计

### 4.1 MQTT通信架构

#### 4.1.1 MQTT主题设计
```typescript
// MQTT主题规范
export const MQTT_TOPICS = {
  // 设备状态上报
  DEVICE_STATUS: 'device/{deviceId}/status',
  // 设备心跳
  DEVICE_HEARTBEAT: 'device/{deviceId}/heartbeat',
  // 设备控制指令
  DEVICE_CONTROL: 'device/{deviceId}/control',
  // 设备响应
  DEVICE_RESPONSE: 'device/{deviceId}/response',
  // 设备告警
  DEVICE_ALARM: 'device/{deviceId}/alarm'
} as const

// 消息格式定义
interface DeviceMessage {
  deviceId: string
  timestamp: number
  messageType: 'status' | 'heartbeat' | 'control' | 'response' | 'alarm'
  payload: any
  signature?: string // 消息签名
}
```

#### 4.1.2 设备通信服务
```typescript
@Injectable()
export class IoTService {
  constructor(
    private mqttClient: MqttClient,
    private deviceService: DeviceService,
    private cacheService: CacheService
  ) {}
  
  // 发送开锁指令
  async sendUnlockCommand(deviceId: string, orderId: string): Promise<boolean> {
    const command = {
      action: 'unlock',
      orderId,
      timestamp: Date.now(),
      timeout: 30000 // 30秒超时
    }
    
    const topic = MQTT_TOPICS.DEVICE_CONTROL.replace('{deviceId}', deviceId)
    
    try {
      await this.mqttClient.publish(topic, JSON.stringify(command))
      
      // 设置指令状态缓存
      await this.cacheService.setDeviceCommand(deviceId, orderId, command, 60)
      
      return true
    } catch (error) {
      console.error('发送开锁指令失败:', error)
      return false
    }
  }
  
  // 处理设备状态上报
  @Subscribe(MQTT_TOPICS.DEVICE_STATUS)
  async handleDeviceStatus(topic: string, message: Buffer): Promise<void> {
    try {
      const deviceId = this.extractDeviceId(topic)
      const statusData = JSON.parse(message.toString())
      
      // 更新设备状态缓存
      await this.cacheService.setDeviceStatus(deviceId, statusData)
      
      // 更新数据库
      await this.deviceService.updateDeviceStatus(deviceId, statusData)
      
      // 发送实时通知
      this.notifyDeviceStatusChange(deviceId, statusData)
      
    } catch (error) {
      console.error('处理设备状态失败:', error)
    }
  }
  
  // 处理设备响应
  @Subscribe(MQTT_TOPICS.DEVICE_RESPONSE)
  async handleDeviceResponse(topic: string, message: Buffer): Promise<void> {
    try {
      const deviceId = this.extractDeviceId(topic)
      const response = JSON.parse(message.toString())
      
      if (response.action === 'unlock') {
        await this.handleUnlockResponse(deviceId, response)
      }
      
    } catch (error) {
      console.error('处理设备响应失败:', error)
    }
  }
  
  private async handleUnlockResponse(deviceId: string, response: any): Promise<void> {
    const { orderId, success, error } = response
    
    if (success) {
      // 更新订单状态为已开锁
      await this.orderService.updateOrderStatus(orderId, 'unlocked')
    } else {
      // 处理开锁失败
      await this.orderService.updateOrderStatus(orderId, 'unlock_failed', error)
    }
  }
}
```

### 4.2 设备安全认证

#### 4.2.1 设备证书管理
```typescript
// 设备认证服务
@Injectable()
export class DeviceAuthService {
  // 设备注册
  async registerDevice(deviceInfo: DeviceRegisterDto): Promise<DeviceCredentials> {
    // 生成设备证书
    const certificate = await this.generateDeviceCertificate(deviceInfo.deviceId)
    
    // 生成设备密钥
    const credentials = {
      deviceId: deviceInfo.deviceId,
      clientId: `device_${deviceInfo.deviceId}`,
      username: deviceInfo.deviceId,
      password: this.generateSecurePassword(),
      certificate: certificate,
      privateKey: certificate.privateKey
    }
    
    // 保存到数据库
    await this.saveDeviceCredentials(credentials)
    
    return credentials
  }
  
  // 设备认证
  async authenticateDevice(deviceId: string, signature: string): Promise<boolean> {
    const credentials = await this.getDeviceCredentials(deviceId)
    if (!credentials) {
      return false
    }
    
    // 验证签名
    return this.verifySignature(deviceId, signature, credentials.certificate)
  }
  
  private generateDeviceCertificate(deviceId: string): DeviceCertificate {
    // 生成设备证书逻辑
    // 使用RSA或ECC算法生成密钥对
    // 返回证书和私钥
  }
}
```

## 五、安全架构设计

### 5.1 身份认证与授权

#### 5.1.1 JWT认证机制
```typescript
// JWT认证服务
@Injectable()
export class AuthService {
  constructor(
    private jwtService: JwtService,
    private userService: UserService,
    private cacheService: CacheService
  ) {}
  
  // 用户登录
  async login(loginDto: LoginDto): Promise<AuthResult> {
    const user = await this.validateUser(loginDto.username, loginDto.password)
    if (!user) {
      throw new UnauthorizedException('用户名或密码错误')
    }
    
    // 生成访问令牌和刷新令牌
    const tokens = await this.generateTokens(user)
    
    // 缓存用户会话
    await this.cacheService.setSession(tokens.sessionId, {
      userId: user.id,
      roles: user.roles,
      permissions: user.permissions
    })
    
    return {
      user: this.sanitizeUser(user),
      accessToken: tokens.accessToken,
      refreshToken: tokens.refreshToken,
      expiresIn: 3600
    }
  }
  
  // 生成令牌
  private async generateTokens(user: User): Promise<TokenPair> {
    const sessionId = uuidv4()
    
    const payload = {
      sub: user.id,
      username: user.username,
      roles: user.roles.map(r => r.name),
      sessionId
    }
    
    const accessToken = this.jwtService.sign(payload, { expiresIn: '1h' })
    const refreshToken = this.jwtService.sign(
      { sub: user.id, sessionId, type: 'refresh' },
      { expiresIn: '7d' }
    )
    
    return { accessToken, refreshToken, sessionId }
  }
  
  // 刷新令牌
  async refreshToken(refreshToken: string): Promise<AuthResult> {
    try {
      const payload = this.jwtService.verify(refreshToken)
      
      if (payload.type !== 'refresh') {
        throw new UnauthorizedException('无效的刷新令牌')
      }
      
      const user = await this.userService.findById(payload.sub)
      if (!user) {
        throw new UnauthorizedException('用户不存在')
      }
      
      // 生成新的访问令牌
      const tokens = await this.generateTokens(user)
      
      return {
        user: this.sanitizeUser(user),
        accessToken: tokens.accessToken,
        refreshToken: tokens.refreshToken,
        expiresIn: 3600
      }
    } catch (error) {
      throw new UnauthorizedException('刷新令牌失败')
    }
  }
}
```

#### 5.1.2 RBAC权限控制
```typescript
// 权限装饰器
export const RequirePermissions = (...permissions: string[]) =>
  SetMetadata('permissions', permissions)

// 权限守卫
@Injectable()
export class PermissionGuard implements CanActivate {
  constructor(private reflector: Reflector) {}
  
  canActivate(context: ExecutionContext): boolean {
    const requiredPermissions = this.reflector.get<string[]>(
      'permissions',
      context.getHandler()
    )
    
    if (!requiredPermissions) {
      return true
    }
    
    const request = context.switchToHttp().getRequest()
    const user = request.user
    
    return this.hasPermissions(user.permissions, requiredPermissions)
  }
  
  private hasPermissions(userPermissions: string[], requiredPermissions: string[]): boolean {
    return requiredPermissions.every(permission =>
      userPermissions.includes(permission)
    )
  }
}

// 使用示例
@Controller('devices')
export class DeviceController {
  @Get()
  @RequirePermissions('device:read')
  async getDevices() {
    // 需要设备读取权限
  }
  
  @Post()
  @RequirePermissions('device:create')
  async createDevice() {
    // 需要设备创建权限
  }
  
  @Put(':id')
  @RequirePermissions('device:update')
  async updateDevice() {
    // 需要设备更新权限
  }
  
  @Delete(':id')
  @RequirePermissions('device:delete')
  async deleteDevice() {
    // 需要设备删除权限
  }
}
```

### 5.2 数据安全

#### 5.2.1 数据加密
```typescript
// 加密服务
@Injectable()
export class EncryptionService {
  private readonly algorithm = 'aes-256-gcm'
  private readonly keyLength = 32
  
  // 对称加密
  encrypt(text: string, key: string): string {
    const iv = crypto.randomBytes(16)
    const cipher = crypto.createCipher(this.algorithm, key)
    
    let encrypted = cipher.update(text, 'utf8', 'hex')
    encrypted += cipher.final('hex')
    
    const authTag = cipher.getAuthTag()
    
    return iv.toString('hex') + ':' + authTag.toString('hex') + ':' + encrypted
  }
  
  decrypt(encryptedData: string, key: string): string {
    const parts = encryptedData.split(':')
    const iv = Buffer.from(parts[0], 'hex')
    const authTag = Buffer.from(parts[1], 'hex')
    const encrypted = parts[2]
    
    const decipher = crypto.createDecipher(this.algorithm, key)
    decipher.setAuthTag(authTag)
    
    let decrypted = decipher.update(encrypted, 'hex', 'utf8')
    decrypted += decipher.final('utf8')
    
    return decrypted
  }
  
  // 密码哈希
  async hashPassword(password: string): Promise<string> {
    const saltRounds = 12
    return bcrypt.hash(password, saltRounds)
  }
  
  async verifyPassword(password: string, hash: string): Promise<boolean> {
    return bcrypt.compare(password, hash)
  }
  
  // 生成随机密钥
  generateKey(length: number = 32): string {
    return crypto.randomBytes(length).toString('hex')
  }
}
```

#### 5.2.2 API安全防护
```typescript
// 请求限流中间件
@Injectable()
export class RateLimitMiddleware implements NestMiddleware {
  private store = new Map<string, { count: number; resetTime: number }>()
  
  use(req: Request, res: Response, next: NextFunction) {
    const key = this.getClientKey(req)
    const now = Date.now()
    const windowMs = 60 * 1000 // 1分钟
    const maxRequests = 100    // 最大请求数
    
    const record = this.store.get(key)
    
    if (!record || now > record.resetTime) {
      this.store.set(key, { count: 1, resetTime: now + windowMs })
      next()
    } else if (record.count < maxRequests) {
      record.count++
      next()
    } else {
      res.status(429).json({ 
        code: 429,
        message: '请求过于频繁，请稍后再试',
        timestamp: now
      })
    }
  }
  
  private getClientKey(req: Request): string {
    return req.ip || req.connection.remoteAddress || 'unknown'
  }
}

// 输入验证和清理
export class SecurityHelper {
  // SQL注入防护
  static validateInput(input: string): boolean {
    const sqlInjectionPattern = /('|(\\')|("|(\\")|(--)|(;)|(\|)|(\*)|(\%)|(\+))/
    return !sqlInjectionPattern.test(input)
  }
  
  // XSS防护
  static sanitizeHtml(html: string): string {
    return DOMPurify.sanitize(html, {
      ALLOWED_TAGS: ['p', 'br', 'strong', 'em', 'u', 'img'],
      ALLOWED_ATTR: ['src', 'alt', 'title']
    })
  }
  
  // CSRF Token生成
  static generateCSRFToken(): string {
    return crypto.randomBytes(32).toString('hex')
  }
}
```

## 六、文件存储方案

### 6.1 OSS集成设计

#### 6.1.1 文件上传服务
```typescript
// 文件上传服务
@Injectable()
export class FileService {
  constructor(private ossClient: OSS) {}
  
  // 图片上传
  async uploadImage(file: Express.Multer.File): Promise<UploadResult> {
    // 文件类型验证
    if (!this.isValidImageType(file.mimetype)) {
      throw new BadRequestException('不支持的图片格式')
    }
    
    // 文件大小验证
    if (file.size > 5 * 1024 * 1024) { // 5MB
      throw new BadRequestException('图片大小不能超过5MB')
    }
    
    const fileName = this.generateFileName(file.originalname)
    const filePath = `images/${fileName}`
    
    const result = await this.ossClient.put(filePath, file.buffer, {
      headers: {
        'Content-Type': file.mimetype,
        'Cache-Control': 'public, max-age=31536000'
      }
    })
    
    return {
      url: result.url,
      filename: fileName,
      size: file.size,
      mimeType: file.mimetype
    }
  }
  
  // 视频上传
  async uploadVideo(file: Express.Multer.File): Promise<UploadResult> {
    if (!this.isValidVideoType(file.mimetype)) {
      throw new BadRequestException('不支持的视频格式')
    }
    
    if (file.size > 100 * 1024 * 1024) { // 100MB
      throw new BadRequestException('视频大小不能超过100MB')
    }
    
    const fileName = this.generateFileName(file.originalname)
    const filePath = `videos/${fileName}`
    
    // 大文件分片上传
    const result = await this.ossClient.multipartUpload(filePath, file.buffer, {
      partSize: 1024 * 1024, // 1MB per part
      headers: {
        'Content-Type': file.mimetype
      }
    })
    
    return {
      url: result.url,
      filename: fileName,
      size: file.size,
      mimeType: file.mimetype
    }
  }
  
  private generateFileName(originalName: string): string {
    const ext = path.extname(originalName)
    const timestamp = Date.now()
    const random = Math.random().toString(36).substring(2)
    return `${timestamp}_${random}${ext}`
  }
  
  private isValidImageType(mimeType: string): boolean {
    const validTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp']
    return validTypes.includes(mimeType)
  }
  
  private isValidVideoType(mimeType: string): boolean {
    const validTypes = ['video/mp4', 'video/avi', 'video/mov', 'video/wmv']
    return validTypes.includes(mimeType)
  }
}
```

#### 6.1.2 CDN加速配置
```typescript
// CDN配置
export const cdnConfig = {
  domain: 'https://cdn.smartlock.com',
  imagePrefix: '/images/',
  videoPrefix: '/videos/',
  staticPrefix: '/static/',
  cacheControl: {
    images: 'public, max-age=31536000', // 1年
    videos: 'public, max-age=2592000',  // 30天
    static: 'public, max-age=604800'    // 7天
  }
}

// URL生成工具
export class UrlHelper {
  static getImageUrl(filename: string): string {
    return `${cdnConfig.domain}${cdnConfig.imagePrefix}${filename}`
  }
  
  static getVideoUrl(filename: string): string {
    return `${cdnConfig.domain}${cdnConfig.videoPrefix}${filename}`
  }
  
  static getStaticUrl(filename: string): string {
    return `${cdnConfig.domain}${cdnConfig.staticPrefix}${filename}`
  }
}
```

## 七、监控和日志系统

### 7.1 日志系统设计

#### 7.1.1 结构化日志
```typescript
// 日志服务
@Injectable()
export class LoggerService {
  private logger = winston.createLogger({
    level: 'info',
    format: winston.format.combine(
      winston.format.timestamp(),
      winston.format.errors({ stack: true }),
      winston.format.json()
    ),
    transports: [
      new winston.transports.File({ 
        filename: 'logs/error.log', 
        level: 'error',
        maxsize: 10485760, // 10MB
        maxFiles: 5
      }),
      new winston.transports.File({ 
        filename: 'logs/combined.log',
        maxsize: 10485760,
        maxFiles: 10
      }),
      new winston.transports.Console({
        format: winston.format.simple()
      })
    ]
  })
  
  // API请求日志
  logApiRequest(req: Request, res: Response, responseTime: number) {
    this.logger.info('API Request', {
      method: req.method,
      url: req.url,
      statusCode: res.statusCode,
      responseTime,
      userAgent: req.get('User-Agent'),
      ip: req.ip,
      userId: req.user?.id
    })
  }
  
  // 业务操作日志
  logBusinessOperation(operation: string, userId: number, details: any) {
    this.logger.info('Business Operation', {
      operation,
      userId,
      details,
      timestamp: new Date().toISOString()
    })
  }
  
  // 设备操作日志
  logDeviceOperation(deviceId: string, operation: string, result: any) {
    this.logger.info('Device Operation', {
      deviceId,
      operation,
      result,
      timestamp: new Date().toISOString()
    })
  }
  
  // 错误日志
  logError(error: Error, context?: any) {
    this.logger.error('Application Error', {
      message: error.message,
      stack: error.stack,
      context,
      timestamp: new Date().toISOString()
    })
  }
}
```

### 7.2 性能监控

#### 7.2.1 应用性能监控
```typescript
// 性能监控中间件
@Injectable()
export class PerformanceMiddleware implements NestMiddleware {
  constructor(private loggerService: LoggerService) {}
  
  use(req: Request, res: Response, next: NextFunction) {
    const startTime = Date.now()
    
    res.on('finish', () => {
      const responseTime = Date.now() - startTime
      
      // 记录API响应时间
      this.loggerService.logApiRequest(req, res, responseTime)
      
      // 慢查询告警
      if (responseTime > 1000) {
        this.loggerService.logError(
          new Error('Slow API Response'),
          {
            url: req.url,
            method: req.method,
            responseTime
          }
        )
      }
    })
    
    next()
  }
}

// 数据库性能监控
@Injectable()
export class DatabaseMonitor {
  constructor(private loggerService: LoggerService) {}
  
  // 监控慢查询
  monitorSlowQuery(query: string, duration: number) {
    if (duration > 500) { // 超过500ms的查询
      this.loggerService.logError(
        new Error('Slow Database Query'),
        {
          query,
          duration,
          timestamp: new Date().toISOString()
        }
      )
    }
  }
}
```

### 7.3 健康检查

#### 7.3.1 服务健康检查
```typescript
// 健康检查服务
@Injectable()
export class HealthService {
  constructor(
    private databaseService: DatabaseService,
    private redisService: RedisService,
    private mqttService: MqttService
  ) {}
  
  // 整体健康检查
  async checkHealth(): Promise<HealthStatus> {
    const checks = await Promise.allSettled([
      this.checkDatabase(),
      this.checkRedis(),
      this.checkMqtt(),
      this.checkDiskSpace(),
      this.checkMemoryUsage()
    ])
    
    const results = checks.map((check, index) => ({
      service: ['database', 'redis', 'mqtt', 'disk', 'memory'][index],
      status: check.status === 'fulfilled' ? 'healthy' : 'unhealthy',
      details: check.status === 'fulfilled' ? check.value : check.reason
    }))
    
    const overallStatus = results.every(r => r.status === 'healthy') 
      ? 'healthy' 
      : 'unhealthy'
    
    return {
      status: overallStatus,
      timestamp: new Date().toISOString(),
      checks: results
    }
  }
  
  private async checkDatabase(): Promise<any> {
    try {
      await this.databaseService.query('SELECT 1')
      return { status: 'connected' }
    } catch (error) {
      throw new Error(`Database connection failed: ${error.message}`)
    }
  }
  
  private async checkRedis(): Promise<any> {
    try {
      await this.redisService.ping()
      return { status: 'connected' }
    } catch (error) {
      throw new Error(`Redis connection failed: ${error.message}`)
    }
  }
  
  private async checkMqtt(): Promise<any> {
    try {
      const connected = this.mqttService.isConnected()
      if (!connected) {
        throw new Error('MQTT not connected')
      }
      return { status: 'connected' }
    } catch (error) {
      throw new Error(`MQTT connection failed: ${error.message}`)
    }
  }
}
```

## 八、部署架构

### 8.1 Docker容器化

#### 8.1.1 Dockerfile配置
```dockerfile
# 后端服务Dockerfile
FROM node:18-alpine AS builder

WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

COPY . .
RUN npm run build

FROM node:18-alpine AS runtime

WORKDIR /app
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/package.json ./

EXPOSE 3000

USER node

CMD ["node", "dist/main.js"]
```

#### 8.1.2 Docker Compose配置
```yaml
# docker-compose.yml
version: '3.8'

services:
  # API网关
  gateway:
    image: kong:3.0
    environment:
      KONG_DATABASE: "off"
      KONG_DECLARATIVE_CONFIG: /kong/declarative/kong.yml
      KONG_PROXY_ACCESS_LOG: /dev/stdout
      KONG_ADMIN_ACCESS_LOG: /dev/stdout
      KONG_PROXY_ERROR_LOG: /dev/stderr
      KONG_ADMIN_ERROR_LOG: /dev/stderr
      KONG_ADMIN_LISTEN: 0.0.0.0:8001
    volumes:
      - ./kong.yml:/kong/declarative/kong.yml
    ports:
      - "8000:8000"
      - "8001:8001"
    depends_on:
      - user-service
      - device-service

  # 用户服务
  user-service:
    build: ./backend/user-service
    environment:
      NODE_ENV: production
      DATABASE_URL: mysql://user:password@mysql:3306/user_db
      REDIS_URL: redis://redis:6379
    depends_on:
      - mysql
      - redis
    networks:
      - backend

  # 设备服务
  device-service:
    build: ./backend/device-service
    environment:
      NODE_ENV: production
      DATABASE_URL: mysql://user:password@mysql:3306/device_db
      REDIS_URL: redis://redis:6379
      MQTT_URL: mqtt://emqx:1883
    depends_on:
      - mysql
      - redis
      - emqx
    networks:
      - backend

  # 订单服务
  order-service:
    build: ./backend/order-service
    environment:
      NODE_ENV: production
      DATABASE_URL: mysql://user:password@mysql:3306/order_db
      REDIS_URL: redis://redis:6379
    depends_on:
      - mysql
      - redis
    networks:
      - backend

  # MySQL数据库
  mysql:
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD: rootpassword
      MYSQL_USER: user
      MYSQL_PASSWORD: password
    volumes:
      - mysql_data:/var/lib/mysql
      - ./database/init:/docker-entrypoint-initdb.d
    ports:
      - "3306:3306"
    networks:
      - backend

  # Redis缓存
  redis:
    image: redis:6.0-alpine
    volumes:
      - redis_data:/data
    ports:
      - "6379:6379"
    networks:
      - backend

  # MQTT Broker
  emqx:
    image: emqx/emqx:5.0
    environment:
      EMQX_NAME: emqx
      EMQX_HOST: 127.0.0.1
    volumes:
      - emqx_data:/opt/emqx/data
    ports:
      - "1883:1883"
      - "8083:8083"
      - "8084:8084"
      - "18083:18083"
    networks:
      - backend

  # Nginx反向代理
  nginx:
    image: nginx:alpine
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./admin-frontend/dist:/usr/share/nginx/html/admin
      - ./user-frontend/dist:/usr/share/nginx/html/user
    ports:
      - "80:80"
      - "443:443"
    depends_on:
      - gateway
    networks:
      - frontend
      - backend

volumes:
  mysql_data:
  redis_data:
  emqx_data:

networks:
  frontend:
  backend:
```

### 8.2 Kubernetes部署

#### 8.2.1 K8s部署配置
```yaml
# k8s/user-service-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: user-service
  labels:
    app: user-service
spec:
  replicas: 3
  selector:
    matchLabels:
      app: user-service
  template:
    metadata:
      labels:
        app: user-service
    spec:
      containers:
      - name: user-service
        image: smartlock/user-service:latest
        ports:
        - containerPort: 3001
        env:
        - name: NODE_ENV
          value: "production"
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: database-secret
              key: user-db-url
        - name: REDIS_URL
          valueFrom:
            secretKeyRef:
              name: redis-secret
              key: redis-url
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 3001
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 3001
          initialDelaySeconds: 5
          periodSeconds: 5

---
apiVersion: v1
kind: Service
metadata:
  name: user-service
spec:
  selector:
    app: user-service
  ports:
  - protocol: TCP
    port: 3001
    targetPort: 3001
  type: ClusterIP
```

### 8.3 CI/CD流水线

#### 8.3.1 GitLab CI配置
```yaml
# .gitlab-ci.yml
stages:
  - test
  - build
  - deploy

variables:
  DOCKER_REGISTRY: registry.smartlock.com
  DOCKER_IMAGE_TAG: $CI_COMMIT_SHA

# 测试阶段
test:
  stage: test
  image: node:18
  script:
    - npm ci
    - npm run test
    - npm run test:e2e
  coverage: '/Lines\s*:\s*(\d+\.\d+)%/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage/cobertura-coverage.xml

# 构建阶段
build:
  stage: build
  image: docker:latest
  services:
    - docker:dind
  script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $DOCKER_REGISTRY
    - docker build -t $DOCKER_REGISTRY/user-service:$DOCKER_IMAGE_TAG ./backend/user-service
    - docker push $DOCKER_REGISTRY/user-service:$DOCKER_IMAGE_TAG
  only:
    - main
    - develop

# 部署到开发环境
deploy:dev:
  stage: deploy
  image: kubectl:latest
  script:
    - kubectl set image deployment/user-service user-service=$DOCKER_REGISTRY/user-service:$DOCKER_IMAGE_TAG
    - kubectl rollout status deployment/user-service
  environment:
    name: development
    url: https://dev.smartlock.com
  only:
    - develop

# 部署到生产环境
deploy:prod:
  stage: deploy
  image: kubectl:latest
  script:
    - kubectl set image deployment/user-service user-service=$DOCKER_REGISTRY/user-service:$DOCKER_IMAGE_TAG
    - kubectl rollout status deployment/user-service
  environment:
    name: production
    url: https://smartlock.com
  when: manual
  only:
    - main
```

## 九、性能优化策略

### 9.1 数据库优化

#### 9.1.1 查询优化
```sql
-- 慢查询优化示例
-- 原始查询（慢）
SELECT * FROM orders o 
JOIN users u ON o.user_id = u.id 
WHERE o.created_at >= '2024-01-01' 
AND u.status = 1;

-- 优化后查询
SELECT o.id, o.order_no, o.total_amount, u.username 
FROM orders o 
JOIN users u ON o.user_id = u.id 
WHERE o.created_at >= '2024-01-01' 
AND u.status = 1
AND o.order_status IN (1, 2)
ORDER BY o.created_at DESC
LIMIT 20;

-- 添加复合索引
CREATE INDEX idx_orders_created_status ON orders(created_at, order_status);
CREATE INDEX idx_users_status ON users(status);
```

#### 9.1.2 分库分表策略
```typescript
// 分表路由策略
@Injectable()
export class ShardingService {
  // 按用户ID分表
  getUserTableName(userId: number): string {
    const shardIndex = userId % 10 // 10个分表
    return `users_${shardIndex}`
  }
  
  // 按时间分表
  getOrderTableName(date: Date): string {
    const year = date.getFullYear()
    const month = String(date.getMonth() + 1).padStart(2, '0')
    return `orders_${year}_${month}`
  }
  
  // 分库路由
  getDatabaseName(merchantId: number): string {
    const dbIndex = merchantId % 3 // 3个数据库
    return `smartlock_db_${dbIndex}`
  }
}
```

### 9.2 缓存优化

#### 9.2.1 多级缓存策略
```typescript
// 多级缓存服务
@Injectable()
export class MultiLevelCacheService {
  private localCache = new Map<string, { data: any; expiry: number }>()
  
  constructor(private redis: Redis) {}
  
  // 获取数据（本地缓存 -> Redis -> 数据库）
  async get<T>(key: string, fallback: () => Promise<T>, ttl: number = 300): Promise<T> {
    // 1. 检查本地缓存
    const localData = this.getFromLocalCache(key)
    if (localData) {
      return localData
    }
    
    // 2. 检查Redis缓存
    const redisData = await this.redis.get(key)
    if (redisData) {
      const data = JSON.parse(redisData)
      this.setLocalCache(key, data, 60) // 本地缓存1分钟
      return data
    }
    
    // 3. 从数据库获取
    const data = await fallback()
    
    // 4. 设置缓存
    await this.redis.setex(key, ttl, JSON.stringify(data))
    this.setLocalCache(key, data, 60)
    
    return data
  }
  
  private getFromLocalCache<T>(key: string): T | null {
    const cached = this.localCache.get(key)
    if (cached && cached.expiry > Date.now()) {
      return cached.data
    }
    this.localCache.delete(key)
    return null
  }
  
  private setLocalCache(key: string, data: any, ttlSeconds: number): void {
    this.localCache.set(key, {
      data,
      expiry: Date.now() + ttlSeconds * 1000
    })
  }
}
```

### 9.3 前端性能优化

#### 9.3.1 代码分割和懒加载
```typescript
// 路由懒加载配置
const routes: RouteRecordRaw[] = [
  {
    path: '/dashboard',
    name: 'Dashboard',
    component: () => import('@/views/dashboard/index.vue'),
    meta: { requiresAuth: true }
  },
  {
    path: '/devices',
    name: 'DeviceManagement',
    component: () => import('@/views/device/index.vue'),
    meta: { requiresAuth: true, permissions: ['device:read'] }
  },
  {
    path: '/orders',
    name: 'OrderManagement',
    component: () => import('@/views/order/index.vue'),
    meta: { requiresAuth: true, permissions: ['order:read'] }
  }
]

// 组件懒加载
export default defineAsyncComponent({
  loader: () => import('./HeavyComponent.vue'),
  loadingComponent: LoadingSpinner,
  errorComponent: ErrorComponent,
  delay: 200,
  timeout: 3000
})
```

#### 9.3.2 资源优化
```typescript
// Vite构建优化配置
export default defineConfig({
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ['vue', 'vue-router', 'pinia'],
          ui: ['element-plus'],
          utils: ['lodash', 'dayjs']
        }
      }
    },
    chunkSizeWarningLimit: 1000
  },
  optimizeDeps: {
    include: ['vue', 'vue-router', 'pinia', 'element-plus']
  }
})
```

## 十、扩展性设计

### 10.1 水平扩展

#### 10.1.1 服务扩展策略
```yaml
# 自动扩展配置
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: user-service-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: user-service
  minReplicas: 2
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
  behavior:
    scaleUp:
      stabilizationWindowSeconds: 60
      policies:
      - type: Percent
        value: 100
        periodSeconds: 15
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
      - type: Percent
        value: 10
        periodSeconds: 60
```

#### 10.1.2 负载均衡策略
```typescript
// 负载均衡配置
export class LoadBalancerConfig {
  // 服务发现配置
  static readonly SERVICE_DISCOVERY = {
    consul: {
      host: 'consul.service.consul',
      port: 8500,
      healthCheck: {
        interval: '10s',
        timeout: '3s',
        deregisterCriticalServiceAfter: '30s'
      }
    }
  }
  
  // 负载均衡算法
  static readonly ALGORITHMS = {
    ROUND_ROBIN: 'round_robin',
    LEAST_CONNECTIONS: 'least_conn',
    IP_HASH: 'ip_hash',
    WEIGHTED_ROUND_ROBIN: 'weighted_round_robin'
  }
}

// Nginx负载均衡配置
const nginxConfig = `
upstream user_service {
    least_conn;
    server user-service-1:3001 weight=3 max_fails=3 fail_timeout=30s;
    server user-service-2:3001 weight=3 max_fails=3 fail_timeout=30s;
    server user-service-3:3001 weight=2 max_fails=3 fail_timeout=30s;
    keepalive 32;
}

upstream device_service {
    ip_hash;
    server device-service-1:3002 weight=1 max_fails=3 fail_timeout=30s;
    server device-service-2:3002 weight=1 max_fails=3 fail_timeout=30s;
    keepalive 32;
}

server {
    listen 80;
    server_name api.smartlock.com;
    
    location /api/v1/users {
        proxy_pass http://user_service;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_connect_timeout 30s;
        proxy_send_timeout 30s;
        proxy_read_timeout 30s;
    }
    
    location /api/v1/devices {
        proxy_pass http://device_service;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_connect_timeout 30s;
        proxy_send_timeout 30s;
        proxy_read_timeout 30s;
    }
}
`
```

### 10.2 数据库扩展

#### 10.2.1 读写分离
```typescript
// 数据库连接管理
@Injectable()
export class DatabaseService {
  private masterConnection: Connection
  private slaveConnections: Connection[]
  private currentSlaveIndex = 0
  
  constructor() {
    this.initializeConnections()
  }
  
  private async initializeConnections() {
    // 主库连接（写操作）
    this.masterConnection = await createConnection({
      type: 'mysql',
      host: process.env.DB_MASTER_HOST,
      port: parseInt(process.env.DB_MASTER_PORT),
      username: process.env.DB_USERNAME,
      password: process.env.DB_PASSWORD,
      database: process.env.DB_NAME,
      pool: {
        min: 5,
        max: 20,
        acquireTimeoutMillis: 30000,
        createTimeoutMillis: 30000,
        destroyTimeoutMillis: 5000,
        idleTimeoutMillis: 30000,
        reapIntervalMillis: 1000,
        createRetryIntervalMillis: 200
      }
    })
    
    // 从库连接（读操作）
    const slaveHosts = process.env.DB_SLAVE_HOSTS.split(',')
    this.slaveConnections = await Promise.all(
      slaveHosts.map(host => createConnection({
        type: 'mysql',
        host: host.trim(),
        port: parseInt(process.env.DB_SLAVE_PORT),
        username: process.env.DB_USERNAME,
        password: process.env.DB_PASSWORD,
        database: process.env.DB_NAME,
        pool: {
          min: 3,
          max: 15
        }
      }))
    )
  }
  
  // 获取写连接
  getWriteConnection(): Connection {
    return this.masterConnection
  }
  
  // 获取读连接（轮询）
  getReadConnection(): Connection {
    const connection = this.slaveConnections[this.currentSlaveIndex]
    this.currentSlaveIndex = (this.currentSlaveIndex + 1) % this.slaveConnections.length
    return connection
  }
  
  // 执行写操作
  async executeWrite(query: string, params?: any[]): Promise<any> {
    return this.masterConnection.query(query, params)
  }
  
  // 执行读操作
  async executeRead(query: string, params?: any[]): Promise<any> {
    const connection = this.getReadConnection()
    return connection.query(query, params)
  }
}
```

#### 10.2.2 分库分表实现
```typescript
// 分片管理器
@Injectable()
export class ShardingManager {
  private shardConfigs: Map<string, ShardConfig> = new Map()
  
  constructor() {
    this.initializeShardConfigs()
  }
  
  private initializeShardConfigs() {
    // 用户表分片配置
    this.shardConfigs.set('users', {
      shardKey: 'id',
      shardCount: 10,
      shardRule: 'hash',
      databases: ['user_db_0', 'user_db_1', 'user_db_2']
    })
    
    // 订单表分片配置
    this.shardConfigs.set('orders', {
      shardKey: 'created_at',
      shardCount: 12,
      shardRule: 'time',
      databases: ['order_db_0', 'order_db_1']
    })
  }
  
  // 获取分片信息
  getShardInfo(tableName: string, shardKey: any): ShardInfo {
    const config = this.shardConfigs.get(tableName)
    if (!config) {
      throw new Error(`No shard config found for table: ${tableName}`)
    }
    
    let shardIndex: number
    let dbIndex: number
    
    switch (config.shardRule) {
      case 'hash':
        shardIndex = this.hashShard(shardKey, config.shardCount)
        dbIndex = shardIndex % config.databases.length
        break
      case 'time':
        shardIndex = this.timeShard(shardKey)
        dbIndex = shardIndex % config.databases.length
        break
      default:
        throw new Error(`Unsupported shard rule: ${config.shardRule}`)
    }
    
    return {
      database: config.databases[dbIndex],
      table: `${tableName}_${shardIndex}`,
      shardIndex,
      dbIndex
    }
  }
  
  private hashShard(key: any, shardCount: number): number {
    const hash = this.simpleHash(String(key))
    return Math.abs(hash) % shardCount
  }
  
  private timeShard(date: Date): number {
    const year = date.getFullYear()
    const month = date.getMonth() + 1
    return (year - 2024) * 12 + month - 1
  }
  
  private simpleHash(str: string): number {
    let hash = 0
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i)
      hash = ((hash << 5) - hash) + char
      hash = hash & hash // Convert to 32-bit integer
    }
    return hash
  }
}

// 分片查询服务
@Injectable()
export class ShardedQueryService {
  constructor(
    private shardingManager: ShardingManager,
    private databaseService: DatabaseService
  ) {}
  
  // 单表查询
  async findById(tableName: string, id: number): Promise<any> {
    const shardInfo = this.shardingManager.getShardInfo(tableName, id)
    const connection = this.databaseService.getConnection(shardInfo.database)
    
    const query = `SELECT * FROM ${shardInfo.table} WHERE id = ?`
    const result = await connection.query(query, [id])
    
    return result[0]
  }
  
  // 跨分片查询
  async findByCondition(tableName: string, condition: any): Promise<any[]> {
    const config = this.shardingManager.getShardConfig(tableName)
    const results: any[] = []
    
    // 如果条件包含分片键，直接查询对应分片
    if (condition[config.shardKey]) {
      const shardInfo = this.shardingManager.getShardInfo(
        tableName, 
        condition[config.shardKey]
      )
      const connection = this.databaseService.getConnection(shardInfo.database)
      const query = this.buildQuery(shardInfo.table, condition)
      const result = await connection.query(query.sql, query.params)
      results.push(...result)
    } else {
      // 否则需要查询所有分片
      const allShards = this.getAllShards(tableName)
      const promises = allShards.map(async (shard) => {
        const connection = this.databaseService.getConnection(shard.database)
        const query = this.buildQuery(shard.table, condition)
        return connection.query(query.sql, query.params)
      })
      
      const allResults = await Promise.all(promises)
      allResults.forEach(result => results.push(...result))
    }
    
    return results
  }
  
  private buildQuery(tableName: string, condition: any): { sql: string; params: any[] } {
    const whereClause = Object.keys(condition)
      .map(key => `${key} = ?`)
      .join(' AND ')
    
    const sql = `SELECT * FROM ${tableName} WHERE ${whereClause}`
    const params = Object.values(condition)
    
    return { sql, params }
  }
}
```

### 10.3 微服务治理

#### 10.3.1 服务注册与发现
```typescript
// 服务注册
@Injectable()
export class ServiceRegistry {
  private consul: Consul
  
  constructor() {
    this.consul = new Consul({
      host: process.env.CONSUL_HOST || 'localhost',
      port: process.env.CONSUL_PORT || 8500
    })
  }
  
  // 注册服务
  async registerService(serviceInfo: ServiceInfo): Promise<void> {
    const registration = {
      id: `${serviceInfo.name}-${serviceInfo.instanceId}`,
      name: serviceInfo.name,
      tags: serviceInfo.tags,
      address: serviceInfo.host,
      port: serviceInfo.port,
      check: {
        http: `http://${serviceInfo.host}:${serviceInfo.port}/health`,
        interval: '10s',
        timeout: '3s',
        deregisterCriticalServiceAfter: '30s'
      }
    }
    
    await this.consul.agent.service.register(registration)
    console.log(`Service ${serviceInfo.name} registered successfully`)
  }
  
  // 注销服务
  async deregisterService(serviceId: string): Promise<void> {
    await this.consul.agent.service.deregister(serviceId)
    console.log(`Service ${serviceId} deregistered successfully`)
  }
  
  // 发现服务
  async discoverService(serviceName: string): Promise<ServiceInstance[]> {
    const services = await this.consul.health.service({
      service: serviceName,
      passing: true
    })
    
    return services.map(service => ({
      id: service.Service.ID,
      name: service.Service.Service,
      host: service.Service.Address,
      port: service.Service.Port,
      tags: service.Service.Tags
    }))
  }
}

// 服务发现客户端
@Injectable()
export class ServiceDiscoveryClient {
  private serviceCache = new Map<string, ServiceInstance[]>()
  private cacheExpiry = new Map<string, number>()
  
  constructor(private serviceRegistry: ServiceRegistry) {
    this.startCacheRefresh()
  }
  
  // 获取服务实例
  async getServiceInstances(serviceName: string): Promise<ServiceInstance[]> {
    const cached = this.serviceCache.get(serviceName)
    const expiry = this.cacheExpiry.get(serviceName)
    
    if (cached && expiry && Date.now() < expiry) {
      return cached
    }
    
    const instances = await this.serviceRegistry.discoverService(serviceName)
    this.serviceCache.set(serviceName, instances)
    this.cacheExpiry.set(serviceName, Date.now() + 30000) // 30秒缓存
    
    return instances
  }
  
  // 负载均衡选择实例
  async selectInstance(serviceName: string, algorithm: string = 'round_robin'): Promise<ServiceInstance> {
    const instances = await this.getServiceInstances(serviceName)
    
    if (instances.length === 0) {
      throw new Error(`No available instances for service: ${serviceName}`)
    }
    
    switch (algorithm) {
      case 'round_robin':
        return this.roundRobinSelect(serviceName, instances)
      case 'random':
        return instances[Math.floor(Math.random() * instances.length)]
      case 'least_connections':
        return this.leastConnectionsSelect(instances)
      default:
        return instances[0]
    }
  }
  
  private roundRobinSelect(serviceName: string, instances: ServiceInstance[]): ServiceInstance {
    const key = `rr_${serviceName}`
    let index = this.serviceCache.get(key) as number || 0
    index = (index + 1) % instances.length
    this.serviceCache.set(key, index)
    return instances[index]
  }
  
  private startCacheRefresh(): void {
    setInterval(() => {
      const now = Date.now()
      for (const [serviceName, expiry] of this.cacheExpiry.entries()) {
        if (now >= expiry) {
          this.serviceCache.delete(serviceName)
          this.cacheExpiry.delete(serviceName)
        }
      }
    }, 10000) // 每10秒清理过期缓存
  }
}
```

#### 10.3.2 熔断器模式
```typescript
// 熔断器实现
export class CircuitBreaker {
  private state: 'CLOSED' | 'OPEN' | 'HALF_OPEN' = 'CLOSED'
  private failureCount = 0
  private lastFailureTime = 0
  private successCount = 0
  
  constructor(
    private failureThreshold: number = 5,
    private timeout: number = 60000,
    private monitoringPeriod: number = 10000
  ) {}
  
  async execute<T>(operation: () => Promise<T>): Promise<T> {
    if (this.state === 'OPEN') {
      if (Date.now() - this.lastFailureTime >= this.timeout) {
        this.state = 'HALF_OPEN'
        this.successCount = 0
      } else {
        throw new Error('Circuit breaker is OPEN')
      }
    }
    
    try {
      const result = await operation()
      this.onSuccess()
      return result
    } catch (error) {
      this.onFailure()
      throw error
    }
  }
  
  private onSuccess(): void {
    this.failureCount = 0
    
    if (this.state === 'HALF_OPEN') {
      this.successCount++
      if (this.successCount >= 3) {
        this.state = 'CLOSED'
      }
    }
  }
  
  private onFailure(): void {
    this.failureCount++
    this.lastFailureTime = Date.now()
    
    if (this.failureCount >= this.failureThreshold) {
      this.state = 'OPEN'
    }
  }
  
  getState(): string {
    return this.state
  }
  
  getMetrics(): any {
    return {
      state: this.state,
      failureCount: this.failureCount,
      lastFailureTime: this.lastFailureTime,
      successCount: this.successCount
    }
  }
}

// 熔断器装饰器
export function CircuitBreakerDecorator(
  failureThreshold: number = 5,
  timeout: number = 60000
) {
  return function (target: any, propertyName: string, descriptor: PropertyDescriptor) {
    const method = descriptor.value
    const circuitBreaker = new CircuitBreaker(failureThreshold, timeout)
    
    descriptor.value = async function (...args: any[]) {
      return circuitBreaker.execute(() => method.apply(this, args))
    }
  }
}

// 使用示例
@Injectable()
export class ExternalApiService {
  @CircuitBreakerDecorator(3, 30000)
  async callExternalApi(data: any): Promise<any> {
    // 调用外部API的逻辑
    const response = await fetch('https://external-api.com/endpoint', {
      method: 'POST',
      body: JSON.stringify(data),
      headers: { 'Content-Type': 'application/json' }
    })
    
    if (!response.ok) {
      throw new Error(`API call failed: ${response.status}`)
    }
    
    return response.json()
  }
}
```

## 十一、监控告警系统

### 11.1 应用监控

#### 11.1.1 Prometheus监控配置
```yaml
# prometheus.yml
global:
  scrape_interval: 15s
  evaluation_interval: 15s

rule_files:
  - "alert_rules.yml"

scrape_configs:
  - job_name: 'user-service'
    static_configs:
      - targets: ['user-service:3001']
    metrics_path: '/metrics'
    scrape_interval: 10s

  - job_name: 'device-service'
    static_configs:
      - targets: ['device-service:3002']
    metrics_path: '/metrics'
    scrape_interval: 10s

  - job_name: 'mysql'
    static_configs:
      - targets: ['mysql-exporter:9104']

  - job_name: 'redis'
    static_configs:
      - targets: ['redis-exporter:9121']

alerting:
  alertmanagers:
    - static_configs:
        - targets:
          - alertmanager:9093
```

#### 11.1.2 告警规则配置
```yaml
# alert_rules.yml
groups:
  - name: application_alerts
    rules:
      - alert: HighErrorRate
        expr: rate(http_requests_total{status=~"5.."}[5m]) > 0.1
        for: 2m
        labels:
          severity: critical
        annotations:
          summary: "High error rate detected"
          description: "Error rate is {{ $value }} for {{ $labels.instance }}"

      - alert: HighResponseTime
        expr: histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m])) > 1
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "High response time detected"
          description: "95th percentile response time is {{ $value }}s"

      - alert: DatabaseConnectionHigh
        expr: mysql_global_status_threads_connected / mysql_global_variables_max_connections > 0.8
        for: 2m
        labels:
          severity: warning
        annotations:
          summary: "Database connection usage high"
          description: "Database connection usage is {{ $value | humanizePercentage }}"

      - alert: RedisMemoryHigh
        expr: redis_memory_used_bytes / redis_memory_max_bytes > 0.9
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "Redis memory usage high"
          description: "Redis memory usage is {{ $value | humanizePercentage }}"

  - name: business_alerts
    rules:
      - alert: DeviceOfflineHigh
        expr: (count(device_status == 0) / count(device_status)) > 0.1
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "High device offline rate"
          description: "{{ $value | humanizePercentage }} of devices are offline"

      - alert: OrderFailureRateHigh
        expr: rate(orders_failed_total[5m]) / rate(orders_total[5m]) > 0.05
        for: 3m
        labels:
          severity: critical
        annotations:
          summary: "High order failure rate"
          description: "Order failure rate is {{ $value | humanizePercentage }}"
```

### 11.2 日志聚合

#### 11.2.1 ELK Stack配置
```yaml
# docker-compose-elk.yml
version: '3.8'

services:
  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:8.5.0
    environment:
      - discovery.type=single-node
      - "ES_JAVA_OPTS=-Xms512m -Xmx512m"
      - xpack.security.enabled=false
    volumes:
      - elasticsearch_data:/usr/share/elasticsearch/data
    ports:
      - "9200:9200"

  logstash:
    image: docker.elastic.co/logstash/logstash:8.5.0
    volumes:
      - ./logstash/config:/usr/share/logstash/pipeline
    ports:
      - "5044:5044"
    depends_on:
      - elasticsearch

  kibana:
    image: docker.elastic.co/kibana/kibana:8.5.0
    environment:
      - ELASTICSEARCH_HOSTS=http://elasticsearch:9200
    ports:
      - "5601:5601"
    depends_on:
      - elasticsearch

  filebeat:
    image: docker.elastic.co/beats/filebeat:8.5.0
    volumes:
      - ./filebeat/filebeat.yml:/usr/share/filebeat/filebeat.yml:ro
      - /var/lib/docker/containers:/var/lib/docker/containers:ro
      - /var/run/docker.sock:/var/run/docker.sock:ro
    depends_on:
      - logstash

volumes:
  elasticsearch_data:
```

#### 11.2.2 Logstash配置
```ruby
# logstash/config/logstash.conf
input {
  beats {
    port => 5044
  }
}

filter {
  if [fields][service] == "user-service" {
    grok {
      match => { "message" => "%{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:level} \[%{DATA:logger}\] %{GREEDYDATA:message}" }
    }
    
    if [level] == "ERROR" {
      mutate {
        add_tag => ["error"]
      }
    }
  }
  
  if [fields][service] == "device-service" {
    json {
      source => "message"
    }
    
    if [deviceId] {
      mutate {
        add_field => { "device_id" => "%{deviceId}" }
      }
    }
  }
  
  date {
    match => [ "timestamp", "ISO8601" ]
  }
  
  mutate {
    remove_field => ["@version", "host", "agent"]
  }
}

output {
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "smartlock-logs-%{+YYYY.MM.dd}"
  }
  
  if "error" in [tags] {
    email {
      to => ["admin@smartlock.com"]
      subject => "SmartLock Error Alert"
      body => "Error occurred: %{message}"
    }
  }
}
```

### 11.3 链路追踪

#### 11.3.1 Jaeger配置
```typescript
// 链路追踪配置
import { NodeSDK } from '@opentelemetry/sdk-node'
import { JaegerExporter } from '@opentelemetry/exporter-jaeger'
import { Resource } from '@opentelemetry/resources'
import { SemanticResourceAttributes } from '@opentelemetry/semantic-conventions'

// 初始化追踪
const jaegerExporter = new JaegerExporter({
  endpoint: process.env.JAEGER_ENDPOINT || 'http://localhost:14268/api/traces'
})

const sdk = new NodeSDK({
  resource: new Resource({
    [SemanticResourceAttributes.SERVICE_NAME]: process.env.SERVICE_NAME || 'smartlock-service',
    [SemanticResourceAttributes.SERVICE_VERSION]: process.env.SERVICE_VERSION || '1.0.0'
  }),
  traceExporter: jaegerExporter
})

sdk.start()

// 自定义追踪装饰器
export function Trace(operationName?: string) {
  return function (target: any, propertyName: string, descriptor: PropertyDescriptor) {
    const method = descriptor.value
    
    descriptor.value = async function (...args: any[]) {
      const tracer = trace.getTracer('smartlock-tracer')
      const span = tracer.startSpan(operationName || `${target.constructor.name}.${propertyName}`)
      
      try {
        span.setAttributes({
          'method.name': propertyName,
          'class.name': target.constructor.name
        })
        
        const result = await method.apply(this, args)
        span.setStatus({ code: SpanStatusCode.OK })
        return result
      } catch (error) {
        span.setStatus({
          code: SpanStatusCode.ERROR,
          message: error.message
        })
        span.recordException(error)
        throw error
      } finally {
        span.end()
      }
    }
  }
}

// 使用示例
@Injectable()
export class DeviceService {
  @Trace('device.unlock')
  async unlockDevice(deviceId: string, orderId: string): Promise<boolean> {
    const span = trace.getActiveSpan()
    span?.setAttributes({
      'device.id': deviceId,
      'order.id': orderId
    })
    
    // 业务逻辑
    const result = await this.iotService.sendUnlockCommand(deviceId, orderId)
    
    span?.setAttributes({
      'unlock.success': result
    })
    
    return result
  }
}
```

## 十二、灾备与恢复

### 12.1 数据备份策略

#### 12.1.1 MySQL备份
```bash
#!/bin/bash
# backup-mysql.sh

# 配置参数
BACKUP_DIR="/backup/mysql"
MYSQL_USER="backup_user"
MYSQL_PASSWORD="backup_password"
MYSQL_HOST="localhost"
RETENTION_DAYS=30

# 创建备份目录
mkdir -p $BACKUP_DIR

# 获取当前时间戳
TIMESTAMP=$(date +"%Y%m%d_%H%M%S")

# 数据库列表
DATABASES=("user_db" "device_db" "order_db" "merchant_db")

# 备份每个数据库
for db in "${DATABASES[@]}"; do
    echo "Backing up database: $db"
    
    # 全量备份
    mysqldump -h$MYSQL_HOST -u$MYSQL_USER -p$MYSQL_PASSWORD \
        --single-transaction \
        --routines \
        --triggers \
        --events \
        --hex-blob \
        $db | gzip > $BACKUP_DIR/${db}_${TIMESTAMP}.sql.gz
    
    if [ $? -eq 0 ]; then
        echo "Backup completed for $db"
    else
        echo "Backup failed for $db"
        exit 1
    fi
done

# 清理过期备份
find $BACKUP_DIR -name "*.sql.gz" -mtime +$RETENTION_DAYS -delete

echo "All database backups completed successfully"
```

#### 12.1.2 Redis备份
```bash
#!/bin/bash
# backup-redis.sh

BACKUP_DIR="/backup/redis"
REDIS_HOST="localhost"
REDIS_PORT="6379"
REDIS_PASSWORD=""
TIMESTAMP=$(date +"%Y%m%d_%H%M%S")

mkdir -p $BACKUP_DIR

# RDB备份
redis-cli -h $REDIS_HOST -p $REDIS_PORT -a $REDIS_PASSWORD BGSAVE

# 等待备份完成
while [ $(redis-cli -h $REDIS_HOST -p $REDIS_PORT -a $REDIS_PASSWORD LASTSAVE) -eq $(redis-cli -h $REDIS_HOST -p $REDIS_PORT -a $REDIS_PASSWORD LASTSAVE) ]; do
    sleep 1
done

# 复制RDB文件
cp /var/lib/redis/dump.rdb $BACKUP_DIR/dump_${TIMESTAMP}.rdb

# 压缩备份文件
gzip $BACKUP_DIR/dump_${TIMESTAMP}.rdb

echo "Redis backup completed: dump_${TIMESTAMP}.rdb.gz"
```

### 12.2 容灾方案

#### 12.2.1 主从切换
```typescript
// 数据库故障转移
@Injectable()
export class DatabaseFailoverService {
  private currentMaster: string
  private slaves: string[]
  private healthCheckInterval: NodeJS.Timeout
  
  constructor() {
    this.currentMaster = process.env.DB_MASTER_HOST
    this.slaves = process.env.DB_SLAVE_HOSTS.split(',')
    this.startHealthCheck()
  }
  
  private startHealthCheck(): void {
    this.healthCheckInterval = setInterval(async () => {
      const isHealthy = await this.checkMasterHealth()
      if (!isHealthy) {
        await this.performFailover()
      }
    }, 10000) // 每10秒检查一次
  }
  
  private async checkMasterHealth(): Promise<boolean> {
    try {
      const connection = await mysql.createConnection({
        host: this.currentMaster,
        user: process.env.DB_USERNAME,
        password: process.env.DB_PASSWORD,
        timeout: 5000
      })
      
      await connection.execute('SELECT 1')
      await connection.end()
      return true
    } catch (error) {
      console.error('Master health check failed:', error)
      return false
    }
  }
  
  private async performFailover(): Promise<void> {
    console.log('Performing database failover...')
    
    // 选择最合适的从库作为新主库
    const newMaster = await this.selectNewMaster()
    
    if (newMaster) {
      // 提升从库为主库
      await this.promoteSlaveToMaster(newMaster)
      
      // 更新配置
      this.currentMaster = newMaster
      this.slaves = this.slaves.filter(slave => slave !== newMaster)
      
      // 通知应用程序更新连接
      await this.notifyApplications(newMaster)
      
      console.log(`Failover completed. New master: ${newMaster}`)
    } else {
      console.error('No suitable slave found for failover')
    }
  }
  
  private async selectNewMaster(): Promise<string | null> {
    for (const slave of this.slaves) {
      const isHealthy = await this.checkSlaveHealth(slave)
      if (isHealthy) {
        return slave
      }
    }
    return null
  }
  
  private async checkSlaveHealth(host: string): Promise<boolean> {
    try {
      const connection = await mysql.createConnection({
        host,
        user: process.env.DB_USERNAME,
        password: process.env.DB_PASSWORD,
        timeout: 5000
      })
      
      // 检查从库延迟
      const [rows] = await connection.execute('SHOW SLAVE STATUS')
      const slaveStatus = rows[0] as any
      
      await connection.end()
      
      return slaveStatus.Slave_IO_Running === 'Yes' && 
             slaveStatus.Slave_SQL_Running === 'Yes' &&
             slaveStatus.Seconds_Behind_Master < 10
    } catch (error) {
      return false
    }
  }
  
  private async promoteSlaveToMaster(host: string): Promise<void> {
    const connection = await mysql.createConnection({
      host,
      user: process.env.DB_USERNAME,
      password: process.env.DB_PASSWORD
    })
    
    // 停止从库复制
    await connection.execute('STOP SLAVE')
    
    // 重置从库状态
    await connection.execute('RESET SLAVE ALL')
    
    await connection.end()
  }
  
  private async notifyApplications(newMaster: string): Promise<void> {
    // 通过配置中心或消息队列通知应用程序
    // 这里可以集成Consul、etcd等配置中心
    console.log(`Notifying applications about new master: ${newMaster}`)
  }
}
```

### 12.3 恢复流程

#### 12.3.1 数据恢复脚本
```bash
#!/bin/bash
# restore-mysql.sh

BACKUP_DIR="/backup/mysql"
MYSQL_USER="root"
MYSQL_PASSWORD="password"
MYSQL_HOST="localhost"

# 检查参数
if [ $# -ne 2 ]; then
    echo "Usage: $0 <database_name> <backup_file>"
    echo "Example: $0 user_db user_db_20240101_120000.sql.gz"
    exit 1
fi

DATABASE=$1
BACKUP_FILE=$2

# 检查备份文件是否存在
if [ ! -f "$BACKUP_DIR/$BACKUP_FILE" ]; then
    echo "Backup file not found: $BACKUP_DIR/$BACKUP_FILE"
    exit 1
fi

echo "Starting restore process for database: $DATABASE"
echo "Using backup file: $BACKUP_FILE"

# 创建数据库（如果不存在）
mysql -h$MYSQL_HOST -u$MYSQL_USER -p$MYSQL_PASSWORD -e "CREATE DATABASE IF NOT EXISTS $DATABASE"

# 恢复数据
if [[ $BACKUP_FILE == *.gz ]]; then
    # 解压并恢复
    gunzip -c $BACKUP_DIR/$BACKUP_FILE | mysql -h$MYSQL_HOST -u$MYSQL_USER -p$MYSQL_PASSWORD $DATABASE
else
    # 直接恢复
    mysql -h$MYSQL_HOST -u$MYSQL_USER -p$MYSQL_PASSWORD $DATABASE < $BACKUP_DIR/$BACKUP_FILE
fi

if [ $? -eq 0 ]; then
    echo "Database restore completed successfully"
else
    echo "Database restore failed"
    exit 1
fi

# 验证恢复结果
TABLE_COUNT=$(mysql -h$MYSQL_HOST -u$MYSQL_USER -p$MYSQL_PASSWORD -e "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema='$DATABASE'" -s -N)
echo "Restored database contains $TABLE_COUNT tables"
```

## 十三、总结

本技术架构设计方案为杜美人管理系统提供了完整的技术实现路径，涵盖了从前端到后端、从数据存储到物联网通信的全栈解决方案。

### 13.1 架构优势

1. **现代化技术栈**：采用Vue 3、TypeScript、Nest.js等前沿技术，保证系统的先进性和可维护性
2. **微服务架构**：模块化设计，支持独立开发、部署和扩展
3. **高可用设计**：多层次的容错机制，确保系统稳定运行
4. **安全可靠**：完善的安全防护体系，保障数据和设备安全
5. **性能优化**：多级缓存、数据库优化等策略，确保系统高性能
6. **易于扩展**：支持水平扩展，满足业务增长需求

### 13.2 实施建议

1. **分阶段实施**：建议按照MVP原则，先实现核心功能，再逐步完善
2. **团队培训**：确保团队熟悉所选技术栈，提供必要的技术培训
3. **代码规范**：严格执行开发规范，确保代码质量
4. **持续集成**：建立完善的CI/CD流程，提高开发效率
5. **监控告警**：及时发现和解决问题，保障系统稳定运行

### 13.3 风险控制

1. **技术风险**：选择成熟稳定的技术方案，避免过于前沿的技术
2. **性能风险**：提前进行性能测试，确保系统能够承受预期负载
3. **安全风险**：建立完善的安全防护体系，定期进行安全审计
4. **运维风险**：建立完善的监控和告警机制，确保问题及时发现和处理

通过本架构设计方案的实施，可以构建一个高性能、高可用、安全可靠的杜美人管理系统，为用户提供优质的服务体验，为企业创造更大的商业价值。